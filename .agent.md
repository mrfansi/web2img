# web2img Development Guide

## Project Overview

**web2img** is a high-performance FastAPI service that captures website screenshots, uploads them to Cloudflare R2 storage, and generates signed imgproxy URLs for image transformations.

### Key Technologies
- **Language**: Python 3.12
- **Framework**: FastAPI with async/await patterns
- **Browser Automation**: Playwright (supports Chromium, Firefox, WebKit)
- **Storage**: Cloudflare R2 (S3-compatible) or local filesystem
- **Image Processing**: imgproxy integration for transformations
- **Testing**: pytest with async support
- **Containerization**: Docker with multi-browser support

### Core Features
- Website screenshot capture with multiple browser engines
- Concurrent request handling with browser pooling
- Intelligent caching system
- Batch processing capabilities
- Health monitoring and metrics
- URL transformation for specific domains
- Automatic resource cleanup and management

## Architecture Overview

### Directory Structure
```
app/
├── api/           # FastAPI route handlers
├── core/          # Core configuration, logging, middleware
├── models/        # Data models
├── schemas/       # Pydantic schemas for API validation
├── services/      # Business logic and external service integrations
├── static/        # Static files (dashboard)
└── utils/         # Utility functions

docs/              # Technical documentation and fixes
scripts/           # Operational scripts for monitoring and scaling
tests/             # Test suite with async utilities
```

### Key Services
- **ScreenshotService**: Core screenshot capture logic with browser management
- **BrowserPool**: Manages browser instances for concurrent operations
- **CacheService**: Handles response caching
- **StorageService**: Abstracts R2/local storage operations
- **BatchService**: Processes multiple screenshots concurrently
- **HealthChecker**: Monitors service health and dependencies

## Development Best Practices

### Code Organization
- Use async/await patterns consistently throughout the codebase
- Implement proper resource management with async context managers
- Follow the service layer pattern for business logic separation
- Use Pydantic models for all data validation and serialization

### Error Handling
- Use custom exception classes in `app/core/errors.py`
- Implement circuit breaker patterns for external service calls
- Always clean up browser resources in finally blocks
- Log errors with structured logging using the configured logger

### Testing Patterns
- Use `tests/utils/async_test_utils.py` for common async testing utilities
- Implement integration tests for critical paths
- Use pytest markers for slow/network tests: `@pytest.mark.slow`, `@pytest.mark.network`
- Clean up async resources after tests to prevent event loop issues

### Browser Management
- Always use the browser pool for screenshot operations
- Implement proper timeout handling for page operations
- Use context managers for browser context lifecycle
- Monitor browser pool health and implement fallback mechanisms

### Configuration Management
- All configuration is environment-based using Pydantic Settings
- Use `.env` files for local development
- Validate configuration on startup
- Implement configuration monitoring for production environments

## Environment Configuration

### Required Environment Variables
```bash
# R2 Storage
R2_ACCESS_KEY_ID=your_access_key_id
R2_SECRET_ACCESS_KEY=your_secret_access_key
R2_ENDPOINT=https://<accountid>.r2.cloudflarestorage.com
R2_BUCKET=your_bucket_name
R2_PUBLIC_URL=https://your-public-url.example.com

# imgproxy
IMGPROXY_BASE_URL=https://your-imgproxy-url.example.com
IMGPROXY_KEY=your_imgproxy_key
IMGPROXY_SALT=your_imgproxy_salt

# Browser Configuration
BROWSER_ENGINE=chromium  # chromium, firefox, or webkit
BROWSER_POOL_MIN_SIZE=4
BROWSER_POOL_MAX_SIZE=12

# Performance Tuning
WORKERS=8
CACHE_ENABLED=true
CACHE_TTL_SECONDS=3600
```

### Optional Configuration
- `STORAGE_MODE`: "r2" (default) or "local"
- `NAVIGATION_TIMEOUT_REGULAR`: Timeout for regular sites (default: 30000ms)
- `NAVIGATION_TIMEOUT_COMPLEX`: Timeout for complex sites (default: 60000ms)
- `PAGE_CREATION_TIMEOUT`: Timeout for creating new pages (default: 10000ms)

## API Endpoints

### Core Endpoints
- `POST /screenshot` - Capture single screenshot
- `POST /batch` - Process multiple screenshots
- `GET /health` - Health check endpoint
- `GET /cache/stats` - Cache statistics
- `GET /monitoring/metrics` - Service metrics

### Monitoring Endpoints
- `GET /browser/pool/status` - Browser pool status
- `GET /browser/cache/stats` - Browser cache statistics
- `GET /monitoring/dashboard` - Web dashboard

## Development Workflow

### Local Setup
1. Create virtual environment: `python -m venv .venv`
2. Activate environment: `source .venv/bin/activate` (Unix) or `.venv\Scripts\activate` (Windows)
3. Install dependencies: `pip install -r requirements.txt`
4. Install Playwright browsers: `playwright install`
5. Copy `.env.example` to `.env` and configure
6. Run development server: `python main.py`

### Testing
```bash
# Run all tests
pytest

# Run specific test categories
pytest -m "not slow"  # Skip slow tests
pytest -m "not network"  # Skip network-dependent tests

# Run with coverage
pytest --cov=app tests/
```

### Docker Development
```bash
# Build image
docker build -t web2img .

# Run container
docker run -p 8000:8000 --env-file .env web2img
```

## Performance Considerations

### Browser Pool Management
- Monitor browser pool utilization via `/browser/pool/status`
- Adjust `BROWSER_POOL_MIN_SIZE` and `BROWSER_POOL_MAX_SIZE` based on load
- Use browser cache for frequently accessed sites
- Implement proper cleanup to prevent resource leaks

### Caching Strategy
- Enable caching for production environments
- Monitor cache hit rates via `/cache/stats`
- Adjust `CACHE_TTL_SECONDS` based on use case requirements
- Consider cache warming for frequently requested URLs

### Scaling Considerations
- Use multiple workers for horizontal scaling
- Monitor memory usage with browser instances
- Implement health checks for load balancer integration
- Use batch endpoints for bulk operations

## Troubleshooting

### Common Issues
1. **Browser Pool Exhaustion**: Check pool status and adjust size limits
2. **Memory Leaks**: Ensure proper resource cleanup in context managers
3. **Timeout Errors**: Adjust navigation timeouts for complex sites
4. **Storage Errors**: Verify R2 credentials and bucket permissions

### Debugging Tools
- Use `/monitoring/dashboard` for real-time metrics
- Check logs with structured logging output
- Monitor browser pool health with provided scripts
- Use health check endpoints for dependency validation

### Emergency Procedures
- Scripts in `/scripts/` directory for emergency scaling
- Configuration validation tools for production deployments
- Health monitoring scripts for automated checks

## Code Style and Conventions

### Python Style
- Follow PEP 8 guidelines
- Use type hints consistently
- Implement proper docstrings for public methods
- Use async/await instead of callbacks

### API Design
- Use Pydantic schemas for request/response validation
- Implement proper HTTP status codes
- Provide detailed error messages with structured responses
- Use consistent naming conventions for endpoints

### Logging
- Use structured logging with context information
- Log at appropriate levels (DEBUG, INFO, WARNING, ERROR)
- Include request IDs for tracing
- Avoid logging sensitive information

## Security Considerations

### Input Validation
- Validate all URLs before processing
- Implement rate limiting for API endpoints
- Sanitize file names and paths
- Use secure defaults for browser configurations

### Storage Security
- Use signed URLs for temporary access
- Implement proper access controls for R2 buckets
- Rotate access keys regularly
- Monitor for unauthorized access patterns

### Browser Security
- Run browsers in sandboxed environments
- Disable unnecessary browser features
- Implement timeout limits to prevent resource exhaustion
- Monitor for suspicious URL patterns